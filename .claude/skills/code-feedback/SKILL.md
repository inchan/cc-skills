---
name: code-feedback
description: Claude Code 작업 결과를 6개 영역(분석, 계획, 구현, 리뷰, 검증, 테스트)에서 평가하고 구체적인 피드백을 생성합니다. 결과 수집, 영역별 점수화, P0/P1/P2 우선순위 피드백, 자기비판, 성찰, 재평가 사이클을 통해 품질을 개선합니다. Use when evaluating code results, generating feedback, reviewing implementation quality, assessing test coverage.
---

# Code Feedback - 결과 기반 피드백 생성기

## Table of Contents

- [Overview](#overview)
- [Phase 1: 결과 수집](#phase-1-결과-수집-collection)
- [Phase 2: 영역별 평가](#phase-2-영역별-평가-evaluation)
- [Phase 3: 피드백 생성](#phase-3-피드백-생성-feedback-generation)
- [Phase 4: 자기비판](#phase-4-자기비판-self-critique)
- [Phase 5: 성찰](#phase-5-성찰-reflection)
- [Phase 6: 개선 및 재평가](#phase-6-개선-및-재평가-improvement--re-evaluation)
- [사용 예시](#사용-예시)
- [설정 옵션](#설정-옵션)
- [Best Practices](#best-practices)

---

## Overview

이 스킬은 Claude Code의 작업 결과를 수집하고, 각 영역별로 평가한 후 구체적인 피드백을 생성합니다.

### 핵심 워크플로우

```
[입력] Claude Code 작업 결과
          ↓
[수집] 6개 영역별 결과 수집
          ↓
[평가] 각 영역별 점수화 + 문제점 식별
          ↓
[피드백 생성] 구체적 개선 사항 제시
          ↓
[자기비판] 피드백의 적절성 검토
          ↓
[성찰] 패턴 인식 및 학습
          ↓
[개선] → [재평가] → 통과시 완료
```

### 평가 영역

1. **분석 (Analysis)** - 요구사항 이해도
2. **계획 (Planning)** - 작업 분해 및 전략
3. **구현 (Implementation)** - 코드 품질 및 SOLID
4. **리뷰 (Review)** - 검토 완전성
5. **검증 (Verification)** - 테스트 및 빌드
6. **테스트 (Testing)** - 테스트 품질 및 커버리지

---

## Phase 1: 결과 수집 (Collection)

Claude Code 작업이 완료된 후, 각 영역의 결과물을 수집합니다.

```markdown
## 결과 수집

### 1. 분석 결과
- **요구사항 정리**: [수집된 요구사항]
- **제약조건**: [식별된 제약]
- **기술 스택**: [사용된 기술]

### 2. 계획 결과
- **작업 분해**: [분해된 작업 목록]
- **의존성 그래프**: [작업 간 의존성]
- **우선순위**: [설정된 우선순위]

### 3. 구현 결과
- **생성된 파일**: [파일 목록]
- **수정된 파일**: [파일 목록]
- **코드 라인 수**: [추가/수정/삭제]

### 4. 리뷰 결과
- **정적 분석**: [lint, type check 결과]
- **수동 리뷰**: [체크리스트 완료 여부]
- **발견된 이슈**: [이슈 목록]

### 5. 검증 결과
- **빌드 상태**: [성공/실패]
- **테스트 통과율**: [X/Y passed]
- **에러 로그**: [에러 내용]

### 6. 테스트 결과
- **테스트 파일**: [테스트 파일 목록]
- **커버리지**: [X%]
- **테스트 유형**: [unit/integration/e2e]
```

---

## Phase 2: 영역별 평가 (Evaluation)

각 영역을 10점 만점으로 평가하고 구체적인 문제점을 식별합니다.

### 2.1 분석 평가

```markdown
## 분석 평가

### 평가 기준

| 항목 | 배점 | 점수 | 평가 |
|------|------|------|------|
| 요구사항 완전성 | 3 | X | [모든 요구사항 포함 여부] |
| 제약조건 식별 | 2 | X | [기술적/비즈니스 제약] |
| 기술 스택 적절성 | 2 | X | [선택 근거 명확성] |
| 경계조건 정의 | 2 | X | [엣지케이스 고려] |
| 비기능 요구사항 | 1 | X | [성능/보안/확장성] |

**총점**: X/10

### 발견된 문제

1. **[문제 1]**
   - 상세: [구체적 설명]
   - 영향: [이로 인한 결과]
   - 위치: [관련 파일/섹션]

2. **[문제 2]**
   - 상세: [구체적 설명]
   - 영향: [이로 인한 결과]
   - 위치: [관련 파일/섹션]
```

### 2.2 계획 평가

```markdown
## 계획 평가

### 평가 기준

| 항목 | 배점 | 점수 | 평가 |
|------|------|------|------|
| 작업 분해 적절성 | 3 | X | [원자 단위로 분해] |
| 의존성 정의 | 2 | X | [순서 및 관계 명확] |
| 우선순위 설정 | 2 | X | [중요도 기반 정렬] |
| 병렬화 전략 | 2 | X | [독립 작업 식별] |
| 시간 추정 | 1 | X | [현실적 예상] |

**총점**: X/10

### 발견된 문제

1. **[문제 1]**
   - 상세: [구체적 설명]
   - 영향: [이로 인한 결과]
```

### 2.3 구현 평가

```markdown
## 구현 평가

### 평가 기준

| 항목 | 배점 | 점수 | 평가 |
|------|------|------|------|
| 기능 완성도 | 2 | X | [요구사항 충족] |
| SOLID 준수 | 2 | X | [원칙 적용 수준] |
| 코드 가독성 | 2 | X | [명명, 구조, 주석] |
| 에러 처리 | 2 | X | [예외 상황 대응] |
| 보안 | 2 | X | [취약점 여부] |

**총점**: X/10

### SOLID 세부 평가

| 원칙 | 점수 | 위반 사항 |
|------|------|----------|
| SRP | X/10 | [단일 책임 위반] |
| OCP | X/10 | [개방-폐쇄 위반] |
| LSP | X/10 | [리스코프 치환 위반] |
| ISP | X/10 | [인터페이스 분리 위반] |
| DIP | X/10 | [의존성 역전 위반] |

### 발견된 문제

1. **[문제 1]**
   - 상세: [구체적 설명]
   - 위치: [file:line]
   - 코드: [문제 코드 스니펫]
```

### 2.4 리뷰 평가

```markdown
## 리뷰 평가

### 평가 기준

| 항목 | 배점 | 점수 | 평가 |
|------|------|------|------|
| 정적 분석 통과 | 3 | X | [lint, type 에러] |
| 체크리스트 완료 | 2 | X | [리뷰 항목 체크] |
| 이슈 식별 | 2 | X | [문제 발견 능력] |
| 개선안 제시 | 2 | X | [해결책 구체성] |
| 우선순위 지정 | 1 | X | [심각도 분류] |

**총점**: X/10

### 발견된 문제

1. **[문제 1]**
   - 상세: [구체적 설명]
```

### 2.5 검증 평가

```markdown
## 검증 평가

### 평가 기준

| 항목 | 배점 | 점수 | 평가 |
|------|------|------|------|
| 빌드 성공 | 3 | X | [빌드 결과] |
| 테스트 통과 | 3 | X | [테스트 결과] |
| 타입 체크 | 2 | X | [타입 에러] |
| 린트 통과 | 1 | X | [린트 결과] |
| 런타임 에러 | 1 | X | [실행 에러] |

**총점**: X/10

### 발견된 문제

1. **[문제 1]**
   - 에러 메시지: [에러 내용]
   - 위치: [file:line]
   - 원인: [추정 원인]
```

### 2.6 테스트 평가

```markdown
## 테스트 평가

### 평가 기준

| 항목 | 배점 | 점수 | 평가 |
|------|------|------|------|
| 커버리지 | 3 | X | [X% / 목표 80%] |
| 테스트 품질 | 2 | X | [행위 테스트 여부] |
| 엣지케이스 | 2 | X | [경계값 테스트] |
| 모킹 적절성 | 2 | X | [의존성 격리] |
| 테스트 독립성 | 1 | X | [상호 의존 여부] |

**총점**: X/10

### 발견된 문제

1. **[문제 1]**
   - 상세: [구체적 설명]
   - 누락된 테스트: [테스트해야 할 케이스]
```

---

## Phase 3: 피드백 생성 (Feedback Generation)

평가 결과를 바탕으로 구체적이고 실행 가능한 피드백을 생성합니다.

```markdown
## 종합 피드백

### 점수 요약

| 영역 | 점수 | 상태 | 우선순위 |
|------|------|------|----------|
| 분석 | X/10 | [Pass/Fail] | P[0-2] |
| 계획 | X/10 | [Pass/Fail] | P[0-2] |
| 구현 | X/10 | [Pass/Fail] | P[0-2] |
| 리뷰 | X/10 | [Pass/Fail] | P[0-2] |
| 검증 | X/10 | [Pass/Fail] | P[0-2] |
| 테스트 | X/10 | [Pass/Fail] | P[0-2] |

**종합 점수**: X/60 (목표: 48/60, 80%)

### 필수 개선 사항 (P0)

#### 1. [개선 항목]

**문제**: [구체적 문제 설명]
**영역**: [해당 영역]
**영향**: [이 문제로 인한 결과]

**개선 방법**:
```typescript
// Before
[문제 코드]

// After
[개선된 코드]
```

**검증 방법**: [개선 확인 방법]

#### 2. [개선 항목]
[같은 형식]

### 권장 개선 사항 (P1)

#### 1. [개선 항목]
[같은 형식이지만 간략하게]

### 선택 개선 사항 (P2)

- [개선 1]: [간략한 설명]
- [개선 2]: [간략한 설명]

### 잘된 점

1. **[좋은 점 1]**: [구체적 설명]
2. **[좋은 점 2]**: [구체적 설명]
```

---

## Phase 4: 자기비판 (Self-Critique)

생성된 피드백의 적절성을 비판적으로 검토합니다.

```markdown
## 피드백 자기비판

### 피드백 품질 평가

| 항목 | 점수 | 근거 |
|------|------|------|
| 구체성 | X/10 | [피드백이 구체적인가] |
| 실행가능성 | X/10 | [바로 적용 가능한가] |
| 정확성 | X/10 | [문제 진단이 정확한가] |
| 우선순위 적절성 | X/10 | [중요도 순으로 정렬] |

### 놓쳤을 수 있는 것

- [놓친 문제 1]
- [놓친 문제 2]

### 과도했을 수 있는 것

- [불필요한 피드백 1]
- [불필요한 피드백 2]

### 대안적 피드백

- [다른 관점의 피드백]
```

---

## Phase 5: 성찰 (Reflection)

평가 과정에서의 학습과 패턴을 인식합니다.

```markdown
## 성찰

### 반복되는 문제 패턴

| 패턴 | 발생 영역 | 근본 원인 | 예방법 |
|------|----------|----------|--------|
| [패턴 1] | [영역] | [원인] | [예방법] |

### 학습된 것

1. **기술적 인사이트**: [발견한 것]
2. **프로세스 개선점**: [개선할 것]

### 다음 작업을 위한 제안

- [제안 1]
- [제안 2]
```

---

## Phase 6: 개선 및 재평가 (Improvement & Re-evaluation)

피드백을 적용하고 재평가합니다.

```markdown
## 개선 결과

### 적용된 개선

| 개선 항목 | 상태 | 결과 |
|----------|------|------|
| [항목 1] | [완료/진행중] | [효과] |
| [항목 2] | [완료/진행중] | [효과] |

### 재평가 점수

| 영역 | 이전 | 이후 | 변화 |
|------|-----|------|------|
| 분석 | X/10 | Y/10 | +Z |
| 계획 | X/10 | Y/10 | +Z |
| 구현 | X/10 | Y/10 | +Z |
| 리뷰 | X/10 | Y/10 | +Z |
| 검증 | X/10 | Y/10 | +Z |
| 테스트 | X/10 | Y/10 | +Z |

**종합**: X/60 → Y/60 (+Z)

### 판정

**상태**: [PASS / FAIL]

- [PASS] 모든 영역 8/10 이상 → 완료
- [FAIL] 미달 영역 존재 → 다음 반복
```

---

## 사용 예시

### 예시 1: API 엔드포인트 구현 결과 평가

```
입력: "사용자 인증 API 구현 결과를 평가해주세요"

1. 결과 수집:
   - 분석: 요구사항 3개, 제약 2개
   - 계획: 5개 작업으로 분해
   - 구현: auth.ts, user.service.ts 생성
   - 리뷰: ESLint 경고 3개
   - 검증: 빌드 성공, 테스트 8/10 통과
   - 테스트: 커버리지 65%

2. 평가:
   - 분석: 8/10 (비기능 요구사항 누락)
   - 계획: 7/10 (병렬화 미고려)
   - 구현: 6/10 (DIP 위반)
   - 리뷰: 7/10 (경고 미해결)
   - 검증: 8/10 (테스트 2개 실패)
   - 테스트: 5/10 (커버리지 미달)

3. 피드백:
   - P0: 테스트 커버리지 80% 달성 필요
   - P0: DIP 위반 수정 (의존성 주입)
   - P1: ESLint 경고 해결
   - P2: 비기능 요구사항 문서화

4. 개선 후 재평가: 41/60 → 52/60
```

---

## 설정 옵션

```yaml
passThreshold: 8          # 각 영역 통과 기준 (10점 만점)
overallTarget: 48         # 종합 목표 점수 (60점 만점)
maxIterations: 5          # 최대 반복 횟수
coverageTarget: 80        # 테스트 커버리지 목표 (%)
```

---

## Best Practices

1. **결과 완전 수집**: 평가 전 모든 영역의 결과물 확보
2. **객관적 점수화**: 감정 배제, 기준에 따른 평가
3. **구체적 피드백**: "개선 필요" 대신 "file.ts:23 에서 X를 Y로 변경"
4. **우선순위 명확화**: P0은 반드시, P2는 선택적
5. **재평가 필수**: 개선 후 반드시 재평가로 효과 확인

---

## Summary

Code Feedback 스킬은 Claude Code 작업 결과를 6개 영역에서 평가하고 구체적인 피드백을 생성합니다:

1. **수집**: 분석/계획/구현/리뷰/검증/테스트 결과
2. **평가**: 각 영역 10점 만점 점수화
3. **피드백**: P0/P1/P2 우선순위별 개선 사항
4. **자기비판**: 피드백 품질 검토
5. **성찰**: 패턴 인식 및 학습
6. **재평가**: 개선 효과 확인

이 접근법은 **결과 중심**으로 실질적인 개선을 이끌어냅니다.
